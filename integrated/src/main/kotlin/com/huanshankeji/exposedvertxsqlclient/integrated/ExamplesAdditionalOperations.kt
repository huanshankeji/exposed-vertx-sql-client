@file:OptIn(ExperimentalEvscApi::class)

package com.huanshankeji.exposedvertxsqlclient.integrated

import com.huanshankeji.exposed.v1.core.asterisk
import com.huanshankeji.exposedvertxsqlclient.DatabaseClient
import com.huanshankeji.exposedvertxsqlclient.ExperimentalEvscApi
import com.huanshankeji.exposedvertxsqlclient.crud.*
import io.vertx.sqlclient.RowSet
import org.jetbrains.exposed.v1.core.Count
import org.jetbrains.exposed.v1.core.ResultRow
import org.jetbrains.exposed.v1.core.eq
import org.jetbrains.exposed.v1.core.statements.buildStatement
import org.jetbrains.exposed.v1.jdbc.Query
import org.jetbrains.exposed.v1.jdbc.select
import org.jetbrains.exposed.v1.jdbc.selectAll

// Mainly generated by Copilot and updated manually. There might be some imperfections and inconsistencies in styles.

internal suspend fun DatabaseClient<*>.selectAllExampleNameRows(): RowSet<ResultRow> =
    executeQuery(Examples.select(Examples.name))

internal suspend fun DatabaseClient<*>.selectAllExampleNames(): List<String> =
    selectAllExampleNameRows().map { it[Examples.name] }

internal suspend fun DatabaseClient<*>.selectAllExampleNameSequence(): Sequence<String> =
    selectAllExampleNameRows().asSequence().map { it[Examples.name] }

// consider splitting this into multiple functions, one function for each operation
suspend fun batchOperations(
    databaseClient: DatabaseClient<*>, crudSupportConfig: CrudSupportConfig
) = with(crudSupportConfig) {
    // Test batchInsert
    val initialNames = listOf("1", "2", "3")
    databaseClient.batchInsert(Examples, initialNames) { statement, name ->
        statement[this.name] = name
    }

    assert(databaseClient.executeQuery(Examples.selectAll()).map { it.toExample() } ==
            initialNames.mapIndexed { index, name -> Example(index, name) })

    // Test batchInsertIgnore (if supported)
    if (dialectSupportsInsertIgnore) {
        val duplicateData = listOf("1", "4")
        databaseClient.batchInsertIgnore(Examples, duplicateData) { statement, name ->
            statement[this.name] = name
        }.also {
            // "1" already exists, so only "4" should be inserted
            assert(it.toList() == listOf(false, true))
        }
    }

    // Test batchUpdate - update all rows with different names based on data
    databaseClient.batchUpdate(
        Examples, initialNames,
        { name -> Examples.name eq name })
    { statement, name -> statement[this.name] = "$name updated" }.also {
        // Each update statement updates all rows
        // also consider changing this to not update all rows
        assert(it.toList() == List(3) { 1 })
    }

    // Verify that the last update was applied
    assert(databaseClient.selectAllExampleNameSequence().take(3).toList() == initialNames.map { "$it updated" })
}


internal fun selectAllWhereNameEq(name: String): Query = Examples.selectAll().where(Examples.name eq name)

internal suspend fun DatabaseClient<*>.insertSelectWhereNameEq(name: String): Int =
    with(Examples) {
        insertSelect(this, selectAllWhereNameEq(name), listOf(this.name))
    }


internal suspend fun DatabaseClient<*>.insertIgnoreSelectWhereNameEq(name: String): Int =
    with(Examples) {
        insertIgnoreSelect(this, selectAllWhereNameEq(name), listOf(this.name))
    }

suspend fun insertSelectOperations(
    databaseClient: DatabaseClient<*>, crudSupportConfig: CrudSupportConfig
) = with(crudSupportConfig) {
    // Insert initial data
    databaseClient.insert(Examples) { it[name] = "Source" }

    // Test insertSelect - copy rows from Examples back into Examples
    databaseClient.insertSelectWhereNameEq("Source").also {
        assert(it == 1)
    }

    // Verify the insert worked
    assert(databaseClient.selectAllExampleNameSequence().count { it == "Source" } == 2)

    // Test insertIgnoreSelect (if supported)
    if (dialectSupportsInsertIgnore)
    // also consider testing when some results are ignored
        databaseClient.insertIgnoreSelectWhereNameEq("Source").also {
            // This might insert or ignore depending on unique constraints
            assert(it >= 0)
        }
}

suspend fun batchInsertSelectOperations(
    databaseClient: DatabaseClient<*>
) {
    val batchNames = listOf("Batch1", "Batch2")

    // Insert initial data
    for (name in batchNames)
        databaseClient.insert(Examples) { it[this.name] = name }

    // Test batchInsertSelect - create multiple insert-select statements

    databaseClient.batchInsertSelect(batchNames.map {
        buildStatement {
            with(Examples) { insert(selectAllWhereNameEq("Batch1"), listOf(name)) }
        }
    })


    // Verify inserts worked
    for (name in batchNames)
        assert(databaseClient.executeQuery(selectAllWhereNameEq(name)).size() == 2)
}

suspend fun selectBatchOperations(
    databaseClient: DatabaseClient<*>
) {
    // Insert test data
    val dataToInsert = listOf("SelectA", "SelectB", "SelectC")
    databaseClient.batchInsert(Examples, dataToInsert) { statement, name ->
        statement[Examples.name] = name
    }

    // Test selectBatch - batch select with different IDs
    val ids = listOf(1, 2, 3)
    val results = databaseClient.batchSelect(Examples, ids, { id ->
        select(name).where(this.id eq id)
    })
    assert(results.map { it.toList() }.toList() == dataToInsert.map { listOf(it) })
}

suspend fun selectOperationShortcuts(
    databaseClient: DatabaseClient<*>
) {
    // Insert test data
    databaseClient.insert(Examples) { it[name] = "TestSelect" }

    // Test selectColumnSetExpression - select a count expression
    val count = databaseClient.selectExpression(
        Examples,
        Count(asterisk),
        { where(Examples.name eq "TestSelect") },
        true // TODO not working
    ).single()
    assert(count == 1L)

    // Test selectSingleEntityIdColumn - select just the ID column as entity ID value
    val insertedId = databaseClient.selectSingleEntityIdColumn(
        Examples,
        Examples.id,
        { where(Examples.name eq "TestSelect") }
    ).single()
    assert(insertedId == 1)
}
