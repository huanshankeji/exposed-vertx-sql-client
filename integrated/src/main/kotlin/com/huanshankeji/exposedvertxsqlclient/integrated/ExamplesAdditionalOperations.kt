@file:OptIn(ExperimentalEvscApi::class)

package com.huanshankeji.exposedvertxsqlclient.integrated

import com.huanshankeji.exposed.v1.core.asterisk
import com.huanshankeji.exposedvertxsqlclient.DatabaseClient
import com.huanshankeji.exposedvertxsqlclient.ExperimentalEvscApi
import com.huanshankeji.exposedvertxsqlclient.crud.*
import io.kotest.matchers.comparables.shouldBeGreaterThanOrEqualTo
import io.kotest.matchers.shouldBe
import io.vertx.sqlclient.RowSet
import org.jetbrains.exposed.v1.core.Count
import org.jetbrains.exposed.v1.core.ResultRow
import org.jetbrains.exposed.v1.core.eq
import org.jetbrains.exposed.v1.core.statements.buildStatement
import org.jetbrains.exposed.v1.jdbc.Query
import org.jetbrains.exposed.v1.jdbc.select
import org.jetbrains.exposed.v1.jdbc.selectAll

// Mainly generated by Copilot and updated manually. There might be some imperfections and inconsistencies in styles.

internal suspend fun DatabaseClient<*>.selectAllExampleNameRows(): RowSet<ResultRow> =
    executeQuery(Examples.select(Examples.name))

internal suspend fun DatabaseClient<*>.selectAllExampleNames(): List<String> =
    selectAllExampleNameRows().map { it[Examples.name] }

internal suspend fun DatabaseClient<*>.selectAllExampleNameSequence(): Sequence<String> =
    selectAllExampleNameRows().asSequence().map { it[Examples.name] }

// consider splitting this into multiple functions, one function for each operation
suspend fun batchOperations(
    databaseClient: DatabaseClient<*>, crudSupportConfig: CrudSupportConfig, rdbmsType: RdbmsType
) = with(crudSupportConfig) {
    // Test batchInsert
    val initialNames = listOf("1", "2", "3")
    databaseClient.batchInsert(Examples, initialNames) { statement, name ->
        statement[this.name] = name
    }

    databaseClient.executeQuery(Examples.selectAll()).map { it.toExample() } shouldBe
            initialNames.mapIndexed { index, name -> Example(index + 1, name) }

    // Test batchInsertIgnore (if supported)
    if (dialectSupportsInsertIgnore) {
        val newIds = listOf(1, 4)
        databaseClient.batchInsertIgnore(Examples, newIds) { statement, id ->
            statement[this.id] = id
            statement[this.name] = id.toString()
        }.also {
            // "1" already exists, so only "4" should be inserted
            it.toList() shouldBe listOf(false, true)
        }
    }

    // Test batchUpdate - update all rows with different names based on data
    databaseClient.batchUpdate(
        Examples, initialNames,
        { name -> Examples.name eq name })
    { statement, name -> statement[this.name] = "$name updated" }.also {
        // Each update statement updates all rows
        // also consider changing this to not update all rows
        it.toList() shouldBe if (rdbmsType != RdbmsType.Oracle) List(3) { 1 } else List(1) { 3 }
    }

    // Verify that the last update was applied
    databaseClient.executeQuery(Examples.select(Examples.name).orderBy(Examples.id).limit(3))
        .map { it[Examples.name] }
        .toList() shouldBe initialNames.map { "$it updated" }
}


internal fun selectAllWhereNameEqQuery(name: String): Query = Examples.selectAll().where(Examples.name eq name)
internal fun selectNameWhereNameEqQuery(name: String): Query =
    Examples.select(Examples.name).where(Examples.name eq name)

suspend fun insertSelectOperations(
    databaseClient: DatabaseClient<*>, crudSupportConfig: CrudSupportConfig
) = with(crudSupportConfig) {
    // Insert initial data
    databaseClient.insert(Examples) { it[name] = "Source" }

    // Test insertSelect - copy rows from Examples back into Examples
    databaseClient.insertSelect(Examples, selectNameWhereNameEqQuery("Source")).also {
        it shouldBe 1
    }

    // Verify the insert worked
    databaseClient.selectAllExampleNameSequence().count { it == "Source" } shouldBe 2

    // Test insertIgnoreSelect (if supported)
    if (dialectSupportsInsertIgnore)
    // also consider testing when some results are ignored
        databaseClient.insertIgnoreSelect(Examples, selectNameWhereNameEqQuery("Source")).also {
            // This might insert or ignore depending on unique constraints
            it shouldBeGreaterThanOrEqualTo 0
        }
}

suspend fun batchInsertSelectOperations(
    databaseClient: DatabaseClient<*>
) {
    val batchNames = listOf("Batch1", "Batch2")

    // Insert initial data
    for (name in batchNames)
        databaseClient.insert(Examples) { it[this.name] = name }

    // Test batchInsertSelect - create multiple insert-select statements

    // originally `batchInsertSelect` but now deprecated
    databaseClient.executeBatchUpdate(batchNames.map { name ->
        buildStatement {
            with(Examples) {
                databaseClient.statementPreparationExposedTransaction {
                    insert(selectNameWhereNameEqQuery(name))
                }
            }
        }
    })

    // Verify inserts worked
    for (name in batchNames)
        databaseClient.executeQuery(selectAllWhereNameEqQuery(name)).size() shouldBe 2
}

suspend fun selectBatchOperations(
    databaseClient: DatabaseClient<*>
) {
    // Insert test data
    val dataToInsert = listOf("SelectA", "SelectB", "SelectC")
    databaseClient.batchInsert(Examples, dataToInsert) { statement, name ->
        statement[Examples.name] = name
    }

    // Test selectBatch - batch select with different IDs
    val ids = listOf(1, 2, 3)
    val results = databaseClient.batchSelect(ids, { id ->
        with(Examples) { select(name).where(this.id eq id) }
    })
    results.map { it.map { it[Examples.name] } }.toList() shouldBe dataToInsert.map { listOf(it) }
}

suspend fun selectOperationShortcuts(
    databaseClient: DatabaseClient<*>
) {
    // Insert test data
    databaseClient.insert(Examples) { it[name] = "TestSelect" }

    // Test selectColumnSetExpression - select a count expression
    val count = databaseClient.selectExpression(
        Examples,
        Count(asterisk),
        { where(Examples.name eq "TestSelect") }
    ).single()
    count shouldBe 1L

    // Test selectSingleEntityIdColumn - select just the ID column as entity ID value
    val insertedId = databaseClient.selectSingleEntityIdColumn(
        Examples,
        Examples.id,
        { where(Examples.name eq "TestSelect") }
    ).single()
    insertedId shouldBe 1
}
