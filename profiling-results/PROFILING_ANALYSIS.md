# TfbBatchUpdateBenchmark Profiling Results

## Overview

This document presents the profiling results for the `_1kBatchUpdate` benchmark comparing two different transaction provider configurations:

1. **WithDatabaseExposedTransactionProvider** (`DatabaseExposedTransactionProvider`)
2. **WithJdbcTransactionExposedTransactionProvider** (`JdbcTransactionExposedTransactionProvider`)

## Profiling Methodology

- **Profiler Used**: Java Flight Recorder (JFR)
- **Flame Graph Generation**: FlameGraph by Brendan Gregg
- **Benchmark Configuration**: 
  - Warm-up: 3 iterations
  - Profiling run: 10 iterations
  - Each iteration: 1,000 async batch updates (20 updates per batch)

## Performance Results

### DatabaseExposedTransactionProvider

**Execution Time**: 135,516ms total (10 iterations)
**Average per iteration**: 13,551ms

### JdbcTransactionExposedTransactionProvider

**Execution Time**: 136,438ms total (10 iterations)
**Average per iteration**: 13,643ms

### Performance Comparison

| Configuration | Total Time (10 iterations) | Avg per Iteration | Relative Performance |
|--------------|---------------------------|-------------------|---------------------|
| DatabaseExposedTransactionProvider | 135,516ms | 13,551ms | **Baseline** |
| JdbcTransactionExposedTransactionProvider | 136,438ms | 13,643ms | +0.68% slower |

**Key Finding**: The `JdbcTransactionExposedTransactionProvider` is approximately **0.68% slower** than `DatabaseExposedTransactionProvider`, which is within the margin of error and suggests they have nearly equivalent performance for this workload.

## Flame Graph Analysis

### Flame Graph Files

1. **DatabaseExposedTransactionProvider Flame Graph**: 
   - File: `tfb-batch-update-database_flamegraph.svg`
   - Unique stack traces: 85
   - File size: 444 KB

2. **JdbcTransactionExposedTransactionProvider Flame Graph**:
   - File: `tfb-batch-update-jdbc_flamegraph.svg`
   - Unique stack traces: 104
   - File size: 586 KB

### Key Observations from Flame Graphs

1. **Stack Complexity**: 
   - The `JdbcTransactionExposedTransactionProvider` shows 22% more unique stack traces (104 vs 85), indicating more complex execution paths.
   - **Detailed Analysis**: See [DETAILED_EXECUTION_PATH_ANALYSIS.md](./DETAILED_EXECUTION_PATH_ANALYSIS.md) for a comprehensive breakdown of the additional execution paths, including:
     - 34 unique transaction context management paths (ThreadLocal operations, lambda wrappers)
     - 14 unique JDBC batch execution paths (different prepared statement lifecycle)
     - 5 unique connection management paths (SSL/TLS initialization, connection pooling)
     - Additional argument processing and type conversion patterns
   - Despite 22% more paths, performance impact is <1% because these additional functions are lightweight and database I/O remains the bottleneck.

2. **Call Stack Depth**:
   - Both configurations show deep call stacks involving:
     - Kotlin coroutines (`kotlinx.coroutines`)
     - Vert.x async operations (`io.vertx`)
     - Exposed database operations (`org.jetbrains.exposed`)
     - PostgreSQL client operations
   - `JdbcTransactionExposedTransactionProvider` adds 1-2 extra frames on average due to `withThreadLocalTransaction()` wrapper and lambda indirection.

3. **Hot Paths** (visible in the flame graphs):
   - Database query execution
   - SQL statement preparation
   - Transaction management
   - Coroutine context switching
   - Network I/O operations

## Detailed Files Available

### JFR Recordings (for further analysis)
- `tfb-batch-update-database.jfr` (1.8 MB)
- `tfb-batch-update-jdbc.jfr` (1.8 MB)

These can be opened with:
- JDK Mission Control (`jmc`)
- IntelliJ IDEA Profiler
- Any JFR-compatible profiler

### Flame Graphs
- `tfb-batch-update-database_flamegraph.svg` - Interactive SVG flame graph
- `tfb-batch-update-jdbc_flamegraph.svg` - Interactive SVG flame graph

Open these SVG files in a web browser to:
- Zoom into specific functions
- See exact time percentages for each stack frame
- Navigate the call hierarchy interactively

### Collapsed Stack Traces
- `tfb-batch-update-database_collapsed.txt` (265 KB)
- `tfb-batch-update-jdbc_collapsed.txt` (370 KB)

These files contain the raw profiling data in collapsed format, showing all execution paths and their sample counts.

### Summary Reports
- `tfb-batch-update-database_summary.html`
- `tfb-batch-update-jdbc_summary.html`

HTML summaries generated by `jfr summary` command.

## Conclusions

1. **Performance Parity**: Both transaction provider implementations show nearly identical performance characteristics, with less than 1% difference.

2. **Transaction Provider Differences**:
   - **DatabaseExposedTransactionProvider**: Creates a new Exposed transaction for each statement preparation call. This is simpler but potentially less efficient.
   - **JdbcTransactionExposedTransactionProvider**: Reuses a single JDBC transaction for better performance. Despite the architectural difference, the performance gain is minimal in this specific workload.

3. **Recommendation**: 
   - For production use, `JdbcTransactionExposedTransactionProvider` is recommended as it's architecturally more sound (reusing transactions).
   - The performance difference is negligible for this workload, so the choice should be based on other factors like resource usage and transaction semantics.

4. **Profiling Insights**:
   - The flame graphs clearly show that the majority of time is spent in database operations and network I/O, not in transaction management overhead.
   - This explains why the different transaction provider strategies have minimal performance impact â€“ the bottleneck is elsewhere.

## How to View the Results

### View Flame Graphs
```bash
# Open in a web browser
firefox profiling-results/tfb-batch-update-database_flamegraph.svg
firefox profiling-results/tfb-batch-update-jdbc_flamegraph.svg

# Or any browser
open profiling-results/tfb-batch-update-database_flamegraph.svg
open profiling-results/tfb-batch-update-jdbc_flamegraph.svg
```

### Analyze JFR Recordings
```bash
# With JDK Mission Control
jmc -open profiling-results/tfb-batch-update-database.jfr

# Or use jfr command-line tool
jfr print --events jdk.ExecutionSample profiling-results/tfb-batch-update-database.jfr
jfr summary profiling-results/tfb-batch-update-database.jfr
```

## Reproducing the Results

To reproduce these profiling results:

```bash
# Run the JFR-based profiling script
./profile-benchmark-jfr.sh

# Convert JFR to flame graphs
python3 jfr-to-flamegraph.py
```

All profiling scripts and tools are included in this repository.

---

**Date**: February 3, 2026
**JDK Version**: OpenJDK 17.0.18
**Environment**: GitHub Actions Runner (Ubuntu 24.04.3 LTS)
